{"ast":null,"code":"import { getBlobFromURL } from './getBlobFromURL';\nimport { isDataUrl, toDataURL, getMimeType } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function shouldEmbed(string) {\n  return string.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssString, baseUrl, options) {\n  if (!shouldEmbed(cssString)) {\n    return Promise.resolve(cssString);\n  }\n\n  const filteredCssString = filterPreferredFontFormat(cssString, options);\n  return Promise.resolve(filteredCssString).then(parseURLs).then(urls => urls.reduce((done, url) => done.then(ret => embed(ret, url, baseUrl, options)), Promise.resolve(filteredCssString)));\n}\nexport function filterPreferredFontFormat(str, {\n  preferredFontFormat\n}) {\n  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, match => {\n    while (true) {\n      const [src,, format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n\n      if (!format) {\n        return '';\n      }\n\n      if (format === preferredFontFormat) {\n        return `src: ${src};`;\n      }\n    }\n  });\n}\nexport function parseURLs(str) {\n  const result = [];\n  str.replace(URL_REGEX, (raw, quotation, url) => {\n    result.push(url);\n    return raw;\n  });\n  return result.filter(url => !isDataUrl(url));\n}\nexport function embed(cssString, resourceURL, baseURL, options, get) {\n  const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n  return Promise.resolve(resolvedURL).then(url => get ? get(url) : getBlobFromURL(url, options)).then(data => {\n    if (typeof data === 'string') {\n      return toDataURL(data, getMimeType(resourceURL));\n    }\n\n    return toDataURL(data.blob, getMimeType(resourceURL) || data.contentType);\n  }).then(dataURL => cssString.replace(urlToRegex(resourceURL), `$1${dataURL}$3`)).then(content => content, () => resolvedURL);\n}\n\nfunction resolveUrl(url, baseUrl) {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url;\n  } // url is absolute already, without protocol\n\n\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url;\n  } // dataURI, mailto:, tel:, etc.\n\n\n  if (url.match(/^[a-z]+:/i)) {\n    return url;\n  }\n\n  const doc = document.implementation.createHTMLDocument();\n  const base = doc.createElement('base');\n  const a = doc.createElement('a');\n  doc.head.appendChild(base);\n  doc.body.appendChild(a);\n\n  if (baseUrl) {\n    base.href = baseUrl;\n  }\n\n  a.href = url;\n  return a.href;\n}\n\nfunction urlToRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${escape(url)})(['\"]?\\\\))`, 'g');\n}\n\nfunction escape(url) {\n  return url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}","map":{"version":3,"sources":["../src/embedResources.ts"],"names":[],"mappings":"AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,SAAT,EAAoB,SAApB,EAA+B,WAA/B,QAAkD,QAAlD;AAEA,MAAM,SAAS,GAAG,4BAAlB;AACA,MAAM,qBAAqB,GAAG,4CAA9B;AACA,MAAM,cAAc,GAAG,oDAAvB;AAEA,OAAM,SAAU,WAAV,CAAsB,MAAtB,EAAoC;AACxC,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,MAA6B,CAAC,CAArC;AACD;AAED,OAAM,SAAU,cAAV,CACJ,SADI,EAEJ,OAFI,EAGJ,OAHI,EAGY;AAEhB,MAAI,CAAC,WAAW,CAAC,SAAD,CAAhB,EAA6B;AAC3B,WAAO,OAAO,CAAC,OAAR,CAAgB,SAAhB,CAAP;AACD;;AAED,QAAM,iBAAiB,GAAG,yBAAyB,CAAC,SAAD,EAAY,OAAZ,CAAnD;AACA,SAAO,OAAO,CAAC,OAAR,CAAgB,iBAAhB,EACJ,IADI,CACC,SADD,EAEJ,IAFI,CAEE,IAAD,IACJ,IAAI,CAAC,MAAL,CACE,CAAC,IAAD,EAAO,GAAP,KAAe,IAAI,CAAC,IAAL,CAAW,GAAD,IAAS,KAAK,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,OAApB,CAAxB,CADjB,EAEE,OAAO,CAAC,OAAR,CAAgB,iBAAhB,CAFF,CAHG,CAAP;AAQD;AAED,OAAM,SAAU,yBAAV,CACJ,GADI,EAEJ;AAAE,EAAA;AAAF,CAFI,EAE4B;AAEhC,SAAO,CAAC,mBAAD,GACH,GADG,GAEH,GAAG,CAAC,OAAJ,CAAY,cAAZ,EAA6B,KAAD,IAAkB;AAC5C,WAAO,IAAP,EAAa;AACX,YAAM,CAAC,GAAD,GAAQ,MAAR,IAAkB,qBAAqB,CAAC,IAAtB,CAA2B,KAA3B,KAAqC,EAA7D;;AAEA,UAAI,CAAC,MAAL,EAAa;AACX,eAAO,EAAP;AACD;;AACD,UAAI,MAAM,KAAK,mBAAf,EAAoC;AAClC,eAAO,QAAQ,GAAG,GAAlB;AACD;AACF;AACF,GAXD,CAFJ;AAcD;AAED,OAAM,SAAU,SAAV,CAAoB,GAApB,EAA+B;AACnC,QAAM,MAAM,GAAa,EAAzB;AAEA,EAAA,GAAG,CAAC,OAAJ,CAAY,SAAZ,EAAuB,CAAC,GAAD,EAAM,SAAN,EAAiB,GAAjB,KAAwB;AAC7C,IAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,WAAO,GAAP;AACD,GAHD;AAKA,SAAO,MAAM,CAAC,MAAP,CAAe,GAAD,IAAS,CAAC,SAAS,CAAC,GAAD,CAAjC,CAAP;AACD;AAED,OAAM,SAAU,KAAV,CACJ,SADI,EAEJ,WAFI,EAGJ,OAHI,EAIJ,OAJI,EAKJ,GALI,EAKkC;AAEtC,QAAM,WAAW,GAAG,OAAO,GAAG,UAAU,CAAC,WAAD,EAAc,OAAd,CAAb,GAAsC,WAAjE;AAEA,SAAO,OAAO,CAAC,OAAR,CAAgB,WAAhB,EACJ,IADI,CACyD,GAAD,IAC3D,GAAG,GAAG,GAAG,CAAC,GAAD,CAAN,GAAc,cAAc,CAAC,GAAD,EAAM,OAAN,CAF5B,EAIJ,IAJI,CAIE,IAAD,IAAS;AACb,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO,SAAS,CAAC,IAAD,EAAQ,WAAW,CAAC,WAAD,CAAnB,CAAhB;AACD;;AAED,WAAO,SAAS,CACd,IAAK,CAAC,IADQ,EAEd,WAAW,CAAC,WAAD,CAAX,IAA4B,IAAK,CAAC,WAFpB,CAAhB;AAID,GAbI,EAcJ,IAdI,CAcE,OAAD,IACJ,SAAS,CAAC,OAAV,CAAkB,UAAU,CAAC,WAAD,CAA5B,EAA2C,KAAK,OAAO,IAAvD,CAfG,EAiBJ,IAjBI,CAkBF,OAAD,IAAa,OAlBV,EAmBH,MAAM,WAnBH,CAAP;AAqBD;;AAED,SAAS,UAAT,CAAoB,GAApB,EAAiC,OAAjC,EAAuD;AACrD;AACA,MAAI,GAAG,CAAC,KAAJ,CAAU,eAAV,CAAJ,EAAgC;AAC9B,WAAO,GAAP;AACD,GAJoD,CAMrD;;;AACA,MAAI,GAAG,CAAC,KAAJ,CAAU,OAAV,CAAJ,EAAwB;AACtB,WAAO,MAAM,CAAC,QAAP,CAAgB,QAAhB,GAA2B,GAAlC;AACD,GAToD,CAWrD;;;AACA,MAAI,GAAG,CAAC,KAAJ,CAAU,WAAV,CAAJ,EAA4B;AAC1B,WAAO,GAAP;AACD;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,cAAT,CAAwB,kBAAxB,EAAZ;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,aAAJ,CAAkB,MAAlB,CAAb;AACA,QAAM,CAAC,GAAG,GAAG,CAAC,aAAJ,CAAkB,GAAlB,CAAV;AAEA,EAAA,GAAG,CAAC,IAAJ,CAAU,WAAV,CAAsB,IAAtB;AACA,EAAA,GAAG,CAAC,IAAJ,CAAS,WAAT,CAAqB,CAArB;;AAEA,MAAI,OAAJ,EAAa;AACX,IAAA,IAAI,CAAC,IAAL,GAAY,OAAZ;AACD;;AAED,EAAA,CAAC,CAAC,IAAF,GAAS,GAAT;AAEA,SAAO,CAAC,CAAC,IAAT;AACD;;AAED,SAAS,UAAT,CAAoB,GAApB,EAA+B;AAC7B,SAAO,IAAI,MAAJ,CAAW,iBAAiB,MAAM,CAAC,GAAD,CAAK,aAAvC,EAAsD,GAAtD,CAAP;AACD;;AAED,SAAS,MAAT,CAAgB,GAAhB,EAA2B;AACzB,SAAO,GAAG,CAAC,OAAJ,CAAY,0BAAZ,EAAwC,MAAxC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { getBlobFromURL } from './getBlobFromURL';\nimport { isDataUrl, toDataURL, getMimeType } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function shouldEmbed(string) {\n    return string.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssString, baseUrl, options) {\n    if (!shouldEmbed(cssString)) {\n        return Promise.resolve(cssString);\n    }\n    const filteredCssString = filterPreferredFontFormat(cssString, options);\n    return Promise.resolve(filteredCssString)\n        .then(parseURLs)\n        .then((urls) => urls.reduce((done, url) => done.then((ret) => embed(ret, url, baseUrl, options)), Promise.resolve(filteredCssString)));\n}\nexport function filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function parseURLs(str) {\n    const result = [];\n    str.replace(URL_REGEX, (raw, quotation, url) => {\n        result.push(url);\n        return raw;\n    });\n    return result.filter((url) => !isDataUrl(url));\n}\nexport function embed(cssString, resourceURL, baseURL, options, get) {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    return Promise.resolve(resolvedURL)\n        .then((url) => get ? get(url) : getBlobFromURL(url, options))\n        .then((data) => {\n        if (typeof data === 'string') {\n            return toDataURL(data, getMimeType(resourceURL));\n        }\n        return toDataURL(data.blob, getMimeType(resourceURL) || data.contentType);\n    })\n        .then((dataURL) => cssString.replace(urlToRegex(resourceURL), `$1${dataURL}$3`))\n        .then((content) => content, () => resolvedURL);\n}\nfunction resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nfunction urlToRegex(url) {\n    return new RegExp(`(url\\\\(['\"]?)(${escape(url)})(['\"]?\\\\))`, 'g');\n}\nfunction escape(url) {\n    return url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}\n//# sourceMappingURL=embedResources.js.map"]},"metadata":{},"sourceType":"module"}