{"ast":null,"code":"/* tslint:disable:max-line-length */\nimport { getDataURLContent } from './util'; // KNOWN ISSUE\n// -----------\n// Can not handle redirect-url, such as when access 'http://something.com/avatar.png'\n// will redirect to 'http://something.com/65fc2ffcc8aea7ba65a1d1feda173540'\n\nconst TIMEOUT = 30000;\nconst cache = {};\n\nfunction isFont(filename) {\n  return /ttf|otf|eot|woff2?/i.test(filename);\n}\n\nexport function getBlobFromURL(url, options) {\n  let href = url.replace(/\\?.*/, '');\n\n  if (isFont(href)) {\n    href = href.replace(/.*\\//, '');\n  }\n\n  if (cache[href]) {\n    return cache[href];\n  } // cache bypass so we dont have CORS issues with cached images\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n\n\n  if (options.cacheBust) {\n    // tslint:disable-next-line\n    url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n  }\n\n  const failed = reason => {\n    let placeholder = '';\n\n    if (options.imagePlaceholder) {\n      const parts = options.imagePlaceholder.split(/,/);\n\n      if (parts && parts[1]) {\n        placeholder = parts[1];\n      }\n    }\n\n    let msg = `Failed to fetch resource: ${url}`;\n\n    if (reason) {\n      msg = typeof reason === 'string' ? reason : reason.message;\n    }\n\n    if (msg) {\n      console.error(msg);\n    }\n\n    return placeholder;\n  };\n\n  const deferred = window.fetch ? window.fetch(url).then(res => res.blob().then(blob => ({\n    blob,\n    contentType: res.headers.get('Content-Type') || ''\n  }))).then(({\n    blob,\n    contentType\n  }) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onloadend = () => resolve({\n      contentType,\n      blob: reader.result\n    });\n\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  })).then(({\n    blob,\n    contentType\n  }) => ({\n    contentType,\n    blob: getDataURLContent(blob)\n  })) : new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n\n    const timeout = () => {\n      reject(new Error(`Timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`));\n    };\n\n    const done = () => {\n      if (req.readyState !== 4) {\n        return;\n      }\n\n      if (req.status !== 200) {\n        reject(new Error(`Failed to fetch resource: ${url}, status: ${req.status}`));\n        return;\n      }\n\n      const encoder = new FileReader();\n\n      encoder.onloadend = () => {\n        resolve({\n          blob: getDataURLContent(encoder.result),\n          contentType: req.getResponseHeader('Content-Type') || ''\n        });\n      };\n\n      encoder.readAsDataURL(req.response);\n    };\n\n    req.onreadystatechange = done;\n    req.ontimeout = timeout;\n    req.responseType = 'blob';\n    req.timeout = TIMEOUT;\n    req.open('GET', url, true);\n    req.send();\n  });\n  const promise = deferred.catch(failed); // cache result\n\n  cache[href] = promise;\n  return promise;\n}","map":{"version":3,"sources":["../src/getBlobFromURL.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* tslint:disable:max-line-length */\nimport { getDataURLContent } from './util';\n// KNOWN ISSUE\n// -----------\n// Can not handle redirect-url, such as when access 'http://something.com/avatar.png'\n// will redirect to 'http://something.com/65fc2ffcc8aea7ba65a1d1feda173540'\nconst TIMEOUT = 30000;\nconst cache = {};\nfunction isFont(filename) {\n    return /ttf|otf|eot|woff2?/i.test(filename);\n}\nexport function getBlobFromURL(url, options) {\n    let href = url.replace(/\\?.*/, '');\n    if (isFont(href)) {\n        href = href.replace(/.*\\//, '');\n    }\n    if (cache[href]) {\n        return cache[href];\n    }\n    // cache bypass so we dont have CORS issues with cached images\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // tslint:disable-next-line\n        url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n    }\n    const failed = (reason) => {\n        let placeholder = '';\n        if (options.imagePlaceholder) {\n            const parts = options.imagePlaceholder.split(/,/);\n            if (parts && parts[1]) {\n                placeholder = parts[1];\n            }\n        }\n        let msg = `Failed to fetch resource: ${url}`;\n        if (reason) {\n            msg = typeof reason === 'string' ? reason : reason.message;\n        }\n        if (msg) {\n            console.error(msg);\n        }\n        return placeholder;\n    };\n    const deferred = window.fetch\n        ? window\n            .fetch(url)\n            .then((res) => res.blob().then((blob) => ({\n            blob,\n            contentType: res.headers.get('Content-Type') || '',\n        })))\n            .then(({ blob, contentType }) => new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve({\n                contentType,\n                blob: reader.result,\n            });\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        }))\n            .then(({ blob, contentType }) => ({\n            contentType,\n            blob: getDataURLContent(blob),\n        }))\n        : new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n            const timeout = () => {\n                reject(new Error(`Timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`));\n            };\n            const done = () => {\n                if (req.readyState !== 4) {\n                    return;\n                }\n                if (req.status !== 200) {\n                    reject(new Error(`Failed to fetch resource: ${url}, status: ${req.status}`));\n                    return;\n                }\n                const encoder = new FileReader();\n                encoder.onloadend = () => {\n                    resolve({\n                        blob: getDataURLContent(encoder.result),\n                        contentType: req.getResponseHeader('Content-Type') || '',\n                    });\n                };\n                encoder.readAsDataURL(req.response);\n            };\n            req.onreadystatechange = done;\n            req.ontimeout = timeout;\n            req.responseType = 'blob';\n            req.timeout = TIMEOUT;\n            req.open('GET', url, true);\n            req.send();\n        });\n    const promise = deferred.catch(failed);\n    // cache result\n    cache[href] = promise;\n    return promise;\n}\n//# sourceMappingURL=getBlobFromURL.js.map"]},"metadata":{},"sourceType":"module"}